<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fun Tech Terminal + Animations</title>
<style>
  /* Reset & basics */
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: black;
    color: #0f0;
    font-family: monospace, monospace;
    overflow: hidden;
  }
  #container {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    background: #111;
    display: flex;
    gap: 10px;
    padding: 5px 10px;
  }
  button.tab-button {
    background: #222;
    color: #0f0;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    font-weight: bold;
    user-select: none;
    transition: background-color 0.3s;
  }
  button.tab-button.active, button.tab-button:hover {
    background: #0f0;
    color: black;
  }
  main {
    flex: 1;
    position: relative;
    overflow: hidden;
  }
  .activity {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    padding: 10px;
    box-sizing: border-box;
  }
  .activity.active {
    display: block;
  }

  /* Terminal */
  #terminal {
    background: black;
    color: #0f0;
    overflow-y: auto;
    font-size: 16px;
    line-height: 1.4;
  }
  #terminal-output {
    white-space: pre-wrap;
    min-height: 80%;
  }
  #terminal-input {
    width: 100%;
    background: black;
    border: none;
    color: #0f0;
    font-family: monospace;
    font-size: 16px;
    padding: 6px;
    box-sizing: border-box;
  }
  #terminal-input:focus {
    outline: none;
  }

  /* Matrix canvas */
  #matrix-canvas {
    width: 100%;
    height: 100%;
    display: block;
    background: black;
  }

  /* Starfield canvas */
  #starfield-canvas {
    width: 100%;
    height: 100%;
    display: block;
    background: black;
  }

  /* Glitch text */
  #glitch-textarea {
    width: 100%;
    height: 70%;
    background: black;
    color: #0f0;
    border: 1px solid #0f0;
    font-family: monospace;
    font-size: 18px;
    resize: none;
    padding: 10px;
    box-sizing: border-box;
  }
  #glitch-output {
    margin-top: 10px;
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 22px;
    color: #0f0;
    min-height: 100px;
  }

  /* Color pulse controls */
  #color-controls {
    margin-top: 15px;
    color: #0f0;
  }
  #color-controls label {
    display: block;
    margin-bottom: 4px;
  }
  #color-controls input[type="range"] {
    width: 100%;
  }

</style>
</head>
<body>

<div id="container">
  <header>
    <button class="tab-button active" data-target="terminal">Terminal</button>
    <button class="tab-button" data-target="matrix">Matrix Rain</button>
    <button class="tab-button" data-target="starfield">Starfield</button>
    <button class="tab-button" data-target="glitch">Glitch Text</button>
  </header>
  <main>
    <!-- Terminal -->
    <section id="terminal" class="activity active" tabindex="0">
      <div id="terminal-output"></div>
      <input id="terminal-input" autocomplete="off" placeholder="Enter command..." />
    </section>

    <!-- Matrix Rain -->
    <section id="matrix" class="activity">
      <canvas id="matrix-canvas"></canvas>
    </section>

    <!-- Starfield -->
    <section id="starfield" class="activity">
      <canvas id="starfield-canvas"></canvas>
      <div id="color-controls">
        <label>Hue: <span id="hue-val">180</span></label>
        <input type="range" id="hue-range" min="0" max="360" value="180" />
        <label>Saturation (%): <span id="sat-val">100</span></label>
        <input type="range" id="sat-range" min="0" max="100" value="100" />
        <label>Lightness (%): <span id="light-val">20</span></label>
        <input type="range" id="light-range" min="0" max="100" value="20" />
        <label>Pulse Speed: <span id="speed-val">2</span></label>
        <input type="range" id="speed-range" min="0" max="10" step="0.1" value="2" />
      </div>
    </section>

    <!-- Glitch Text -->
    <section id="glitch" class="activity">
      <textarea id="glitch-textarea" placeholder="Type something to glitch it..."></textarea>
      <pre id="glitch-output"></pre>
    </section>
  </main>
</div>

<script>
(() => {
  // Tab switching
  const tabs = document.querySelectorAll('.tab-button');
  const activities = document.querySelectorAll('.activity');

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const target = tab.getAttribute('data-target');
      // Show target activity, hide others
      activities.forEach(act => {
        act.classList.toggle('active', act.id === target);
      });
      // Highlight active tab
      tabs.forEach(t => t.classList.toggle('active', t === tab));
    });
  });

  /* ===== Terminal ===== */
  const terminalOutput = document.getElementById('terminal-output');
  const terminalInput = document.getElementById('terminal-input');

  const jokes = [
    "Why do programmers prefer dark mode? Because light attracts bugs!",
    "Why do Java developers wear glasses? Because they don't C#!",
    "There are only 10 types of people: those who understand binary and those who don't.",
  ];

  function terminalPrint(text) {
    terminalOutput.textContent += text + "\n";
    terminalOutput.scrollTop = terminalOutput.scrollHeight;
  }

  function showHelp() {
    terminalPrint("Available commands:\nhelp - Show this help\n" +
      "time - Show current time\n" +
      "joke - Tell a joke\n" +
      "secret - Reveal a secret\n" +
      "clear - Clear the terminal\n" +
      "switch [matrix|starfield|glitch|terminal] - Switch tab");
  }

  terminalPrint("Welcome to the Fun Tech Terminal!\nType 'help' for commands.");

  terminalInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const input = terminalInput.value.trim();
      terminalInput.value = '';
      terminalPrint("> " + input);

      if (!input) return;

      const [cmd, ...args] = input.split(' ');

      switch (cmd.toLowerCase()) {
        case 'help':
          showHelp();
          break;
        case 'time':
          terminalPrint(new Date().toLocaleString());
          break;
        case 'joke':
          terminalPrint(jokes[Math.floor(Math.random() * jokes.length)]);
          break;
        case 'secret':
          terminalPrint("You found the secret! ðŸŽ‰");
          break;
        case 'clear':
          terminalOutput.textContent = '';
          break;
        case 'switch':
          const target = args[0];
          if (!target) {
            terminalPrint("Usage: switch [matrix|starfield|glitch|terminal]");
            break;
          }
          const tabToSwitch = Array.from(tabs).find(t => t.getAttribute('data-target') === target.toLowerCase());
          if (tabToSwitch) {
            tabToSwitch.click();
          } else {
            terminalPrint(`Unknown tab: ${target}`);
          }
          break;
        default:
          terminalPrint(`Unknown command: ${cmd}`);
      }
    }
  });

  /* ===== Matrix Rain ===== */
  const matrixCanvas = document.getElementById('matrix-canvas');
  const matrixCtx = matrixCanvas.getContext('2d');
  const matrixChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$%&*+-'.split('');
  let matrixColumns, matrixDrops = [];

  function resizeMatrix() {
    matrixCanvas.width = matrixCanvas.clientWidth * devicePixelRatio;
    matrixCanvas.height = matrixCanvas.clientHeight * devicePixelRatio;
    matrixCtx.setTransform(1, 0, 0, 1, 0, 0);
    matrixCtx.scale(devicePixelRatio, devicePixelRatio);

    matrixColumns = Math.floor(matrixCanvas.clientWidth / 20);
    matrixDrops = [];
    for (let i = 0; i < matrixColumns; i++) {
      matrixDrops[i] = Math.random() * matrixCanvas.clientHeight;
    }
  }
  resizeMatrix();
  window.addEventListener('resize', resizeMatrix);

  function drawMatrix() {
    if (!document.getElementById('matrix').classList.contains('active')) {
      requestAnimationFrame(drawMatrix);
      return; // skip drawing if tab not active
    }
    matrixCtx.fillStyle = 'rgba(0,0,0,0.1)';
    matrixCtx.fillRect(0, 0, matrixCanvas.clientWidth, matrixCanvas.clientHeight);
    matrixCtx.fillStyle = '#0F0';
    matrixCtx.font = '20px monospace';

    for (let i = 0; i < matrixColumns; i++) {
      const text = matrixChars[Math.floor(Math.random() * matrixChars.length)];
      matrixCtx.fillText(text, i * 20, matrixDrops[i]);
      matrixDrops[i] += 20;
      if (matrixDrops[i] > matrixCanvas.clientHeight && Math.random() > 0.975) {
        matrixDrops[i] = 0;
      }
    }
    requestAnimationFrame(drawMatrix);
  }
  drawMatrix();

  /* ===== Starfield ===== */
  const starCanvas = document.getElementById('starfield-canvas');
  const starCtx = starCanvas.getContext('2d');

  let starW, starH, centerX, centerY;
  const numStars = 200;
  const stars = [];

  let velocityX = 0;
  let velocityY = 0;

  function randomStar() {
    return {
      x: Math.random() * starW - centerX,
      y: Math.random() * starH - centerY,
      z: Math.random() * starW,
    };
  }

  function resizeStarfield() {
    starCanvas.width = starCanvas.clientWidth * devicePixelRatio;
    starCanvas.height = starCanvas.clientHeight * devicePixelRatio;
    starCtx.setTransform(1, 0, 0, 1, 0, 0);
    starCtx.scale(devicePixelRatio, devicePixelRatio);

    starW = starCanvas.clientWidth;
    starH = starCanvas.clientHeight;
    centerX = starW / 2;
    centerY = starH / 2;

    stars.length = 0;
    for (let i = 0; i < numStars; i++) {
      stars.push(randomStar());
    }
  }
  resizeStarfield();
  window.addEventListener('resize', resizeStarfield);

  function drawStarfield() {
    if (!document.getElementById('starfield').classList.contains('active')) {
      requestAnimationFrame(drawStarfield);
      return; // skip drawing if tab not active
    }
    starCtx.fillStyle = 'black';
    starCtx.fillRect(0, 0, starW, starH);

    starCtx.fillStyle = `hsl(${hueRange.value}, ${satRange.value}%, ${lightRange.value}%)`;
    stars.forEach(s => {
      s.z -= 4 + velocityY;
      if (s.z <= 1) {
        Object.assign(s, randomStar());
        s.z = starW;
      }
      const sx = centerX + (s.x / s.z) * starW;
      const sy = centerY + (s.y / s.z) * starH;
      const size = (1 - s.z / starW) * 3;
      if (sx < 0 || sx > starW || sy < 0 || sy > starH) return;
      starCtx.beginPath();
      starCtx.arc(sx, sy, size, 0, 2 * Math.PI);
      starCtx.fill();
    });
    requestAnimationFrame(drawStarfield);
  }
  drawStarfield();

  // Mouse controls for starfield velocity
  starCanvas.addEventListener('mousemove', (e) => {
    const rect = starCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    velocityX = (mx - starW / 2) * 0.001;
    velocityY = (my - starH / 2) * 0.001;
  });

  window.addEventListener('keydown', (e) => {
    switch (e.key) {
      case 'ArrowUp': velocityY -= 0.005; break;
      case 'ArrowDown': velocityY += 0.005; break;
      case 'ArrowLeft': velocityX -= 0.005; break;
      case 'ArrowRight': velocityX += 0.005; break;
    }
  });

  /* ===== Glitch Text ===== */
  const glitchTextarea = document.getElementById('glitch-textarea');
  const glitchOutput = document.getElementById('glitch-output');
  const glitchChars = ['â–ˆ', 'â–“', 'â–’', 'â–‘', '@', '#', '$', '%', '&', '?'];

  function glitchify(text) {
    let output = '';
    for (let c of text) {
      if (Math.random() < 0.3 && c !== ' ') {
        output += glitchChars[Math.floor(Math.random() * glitchChars.length)];
      } else {
        output += c;
      }
    }
    return output;
  }

  glitchTextarea.addEventListener('input', () => {
    glitchOutput.textContent = glitchify(glitchTextarea.value);
  });

  /* ===== Color Pulse Background ===== */
  const hueRange = document.getElementById('hue-range');
  const satRange = document.getElementById('sat-range');
  const lightRange = document.getElementById('light-range');
  const speedRange = document.getElementById('speed-range');
  const hueVal = document.getElementById('hue-val');
  const satVal = document.getElementById('sat-val');
  const lightVal = document.getElementById('light-val');
  const speedVal = document.getElementById('speed-val');

  let pulseStart = performance.now();

  function updateBg(time) {
    const elapsed = (time - pulseStart) / 1000;
    const speed = parseFloat(speedRange.value);
    const hue = parseInt(hueRange.value);
    const sat = parseInt(satRange.value);
    const light = parseInt(lightRange.value);

    hueVal.textContent = hue;
    satVal.textContent = sat;
    lightVal.textContent = light;
    speedVal.textContent = speed.toFixed(1);

    const pulse = Math.min(Math.max(Math.sin(elapsed * speed) * 20 + light, 0), 100);

    document.body.style.background = `hsl(${hue}, ${sat}%, ${pulse}%)`;
    requestAnimationFrame(updateBg);
  }
  updateBg(pulseStart);

})();
</script>

</body>
</html>
